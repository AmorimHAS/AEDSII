# Relatório: QuickSort com Variação na Escolha do Pivô

## 1. Funcionamento de Cada Estratégia de Escolha do Pivô

- **Primeiro elemento:** O pivô é sempre o primeiro elemento do subarray. Simples, mas pode gerar partições desbalanceadas em arrays ordenados/quase ordenados.
- **Último elemento:** O pivô é sempre o último elemento do subarray. Também simples, mas sofre dos mesmos problemas do anterior.
- **Pivô aleatório:** O pivô é escolhido aleatoriamente dentro do subarray, reduzindo a chance de pior caso.
- **Mediana de três:** O pivô é a mediana entre o primeiro, o meio e o último elemento, melhorando o balanceamento das partições.

## 2. Desempenho Observado

### Visualização dos resultados

#### Gráfico de linhas (exemplo para arrays ordenados)

Você pode visualizar os tempos de execução das estratégias com um gráfico de linhas, onde o eixo X representa o tamanho do array e o eixo Y o tempo (ms). Cada linha representa uma estratégia de pivô.

Exemplo de código Python (matplotlib):

```python
import matplotlib.pyplot as plt

sizes = [100, 1000, 10000]
primeiro = [0.920, 1.222, 37.688]
ultimo = [0.238, 1.289, 44.905]
aleatorio = [0.255, 0.625, 0.812]
mediana = [0.019, 0.333, 0.315]

plt.plot(sizes, primeiro, marker='o', label='Primeiro elemento')
plt.plot(sizes, ultimo, marker='o', label='Último elemento')
plt.plot(sizes, aleatorio, marker='o', label='Aleatório')
plt.plot(sizes, mediana, marker='o', label='Mediana de três')
plt.xlabel('Tamanho do array')
plt.ylabel('Tempo (ms)')
plt.title('QuickSort - Arrays Ordenados')
plt.legend()
plt.grid(True)
plt.show()
```

#### Gráfico de barras (exemplo para arrays ordenados, tamanho 10000)

O gráfico de barras permite comparar diretamente o tempo de cada estratégia para um tamanho específico de array.

Exemplo de código Python:

```python
import matplotlib.pyplot as plt

estrategias = ['Primeiro', 'Último', 'Aleatório', 'Mediana de três']
tempos = [37.688, 44.905, 0.812, 0.315]

plt.bar(estrategias, tempos, color=['blue', 'orange', 'green', 'red'])
plt.ylabel('Tempo (ms)')
plt.title('QuickSort - Arrays Ordenados (10000 elementos)')
plt.show()
```

Esses gráficos ajudam a visualizar claramente a diferença de desempenho entre as estratégias de escolha do pivô.

Os testes foram realizados com arrays de 100, 1.000 e 10.000 elementos, nos cenários: ordenado, quase ordenado e aleatório. O tempo de execução foi medido em nanossegundos e milissegundos (com casas decimais) para cada estratégia:

### Resultados dos testes

#### Tamanho do array: 100
Tipo: Ordenado
  Primeiro elemento: 0,920100 ms
  Último elemento: 0,238300 ms
  Aleatório: 0,255100 ms
  Mediana de três: 0,018500 ms
Tipo: Quase Ordenado
  Primeiro elemento: 0,030400 ms
  Último elemento: 0,042600 ms
  Aleatório: 0,088200 ms
  Mediana de três: 0,017600 ms
Tipo: Aleatório
  Primeiro elemento: 0,017100 ms
  Último elemento: 0,018400 ms
  Aleatório: 0,076600 ms
  Mediana de três: 0,021800 ms

#### Tamanho do array: 1000
Tipo: Ordenado
  Primeiro elemento: 1,221900 ms
  Último elemento: 1,288500 ms
  Aleatório: 0,624900 ms
  Mediana de três: 0,332800 ms
Tipo: Quase Ordenado
  Primeiro elemento: 0,529700 ms
  Último elemento: 0,355800 ms
  Aleatório: 0,085800 ms
  Mediana de três: 0,044900 ms
Tipo: Aleatório
  Primeiro elemento: 0,066800 ms
  Último elemento: 0,035600 ms
  Aleatório: 0,099200 ms
  Mediana de três: 0,038200 ms

#### Tamanho do array: 10000
Tipo: Ordenado
  Primeiro elemento: 37,688000 ms
  Último elemento: 44,904700 ms
  Aleatório: 0,811800 ms
  Mediana de três: 0,315300 ms
Tipo: Quase Ordenado
  Primeiro elemento: 0,704200 ms
  Último elemento: 0,900600 ms
  Aleatório: 0,811100 ms
  Mediana de três: 0,303400 ms
Tipo: Aleatório
  Primeiro elemento: 0,503500 ms
  Último elemento: 0,483800 ms
  Aleatório: 0,968300 ms
  Mediana de três: 0,511000 ms

Esses resultados mostram que as estratégias de pivô fixo (primeiro/último elemento) têm desempenho muito inferior em arrays ordenados grandes, enquanto as demais mantêm desempenho estável e eficiente.

## 3. Discussão

- Estratégias fixas (primeiro/último elemento) tendem a ser menos eficientes em arrays ordenados/quase ordenados, pois geram partições desbalanceadas.
- O pivô aleatório melhora o desempenho médio, evitando o pior caso.
- A mediana de três geralmente apresenta o melhor desempenho, pois evita extremos e gera partições mais equilibradas.

## 4. Conclusão

A escolha do pivô é determinante para o desempenho do QuickSort, especialmente em arrays grandes ou com padrões específicos. Estratégias fixas (primeiro/último elemento) podem ser muito ineficientes em dados ordenados, enquanto o pivô aleatório e a mediana de três mantêm desempenho estável e eficiente na maioria dos cenários. A mediana de três, em especial, tende a evitar partições desbalanceadas, sendo a mais indicada para uso geral. Para uma análise mais precisa, é fundamental realizar testes com grandes volumes de dados e múltiplas execuções, observando sempre o perfil dos dados a serem ordenados.
